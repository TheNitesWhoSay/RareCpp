# Rare Object Mapper

A library for easily mapping between different types, taking advantage of reflection, standard language conversion mechanics, and object mapper-specific customizations.

Any two reflected objects containing fields of the same name and compatible types can be mapped to eachother with zero additional setup, e.g.

```C++
struct PersonDao
{
    int id;
    std::string firstName;
    std::string lastName;

    REFLECT(PersonDao, id, firstName, lastName)
};

struct PersonDto
{
    std::string firstName;
    std::string lastName;

    REFLECT(PersonDto, firstName, lastName)
};

int main()
{
    PersonDao dao{ 1337, "Leeroy", "Jenkins" };
    PersonDto dto{};
    ObjectMapper::map(dto, dao);
    std::cout << "dto: " << Json::pretty(dto) << std::endl;
}
```

```
dto: {
  "firstName": "Leeroy",
  "lastName": "Jenkins"
}
```

The above could also could have been compressed to one line with single-argument helper function:
```C++
  PersonDto dto = ObjectMapper::map<PersonDto>(dao);
```

## Automated Mapping Algorithm

When calling ObjectMapper::map, the order in which various mappings are attempted is as follows:
- Specializations of ObjectMapper::map<To, From>(To &, const From &)
- A matching map_from method in the destination/To class (may be generated by the MAP_FROM or MAP_WITH macro)
- A matching map_to method in the source/From class (may be generated by the MAP_TO or MAP_WITH macro)

Not finding any such (or if the above make explicit calls to ObjectMapper::map_default), the following is then considered in order:
- If To and From are compatible shared_ptrs, the source value is shared to target
- If To or From is a non-null pointer, it is dereferenced
- If To is a null unique or shared pointer, it is allocated then mapped to
- If the statement "to = from" is valid, then it is ran (user defined assignment or conversion operators, converting constructors)
- If the statement "to = static_cast<To>(from)" is valid, then it is ran (user defined explicit conversion operators)
- If to and from are both pairs or tuples, the individual values within are mapped to eachother
- If to and from are both STL containers or static arrays, the container "to" is cleared, then all the elements from "from" are constructed, recursively mapped, then added to it
- If to and from are both reflected, then a mapping is performed on all matching field names

If none of the above are satisfied, no mapping is performed; no exception is raised nor is any other indiciation given that there was no mapping found


## Defining Mappings / Best Practices

1.) If there are pre-existing user-defined assignment operators, user-defined conversion operators, or converting constructors appropriate for your mapping, do nothing! ObjectMapper will find them and use them automatically; consider adding assignment/conversion operators or constructors where they make sense in your codebase as these are more standard (albeit a little more work).

2.) When it is reasonable to do so, name source and target fields the same and add reflection to both objects; no additional code will be needed to perform mappings
  
3.) When one or both objects cannot be reflected within their own class, but the field names are the same and the fields are public or protected, consider adding a reflection proxy, e.g.
```C++
template <> struct Reflect::Proxy<PersonDao> : public PersonDao
{
    REFLECT(Reflect::Proxy<PersonDao>, id, firstName, lastName)
};
```

4.) When one or both objects cannot be reflected or the field names differ, but the types are compatible for mapping, consider the MAP_WITH macro (or MAP_FROM/MAP_TO for uni-directional mappings) wherein the left side is the fields from "this" and the right side the fields from the class you specify e.g. 
```C++
struct UnownedObjDao
{
    int a;
    int b;
    int c;
    std::map<int, int> d;
    std::vector<OwnedObject2> e;

    UnownedObjDao() : a(0), b(0), c(0), d({}), e({}) {}
};

struct OwnedObjectModel
{
    int a;
    int b;
    std::map<int, int> c;
    std::vector<OwnedObject1> d;

    MAP_WITH(UnownedObjDao,
        (a, a),
        (b, b),
        (c, d),
        (d, e)
    )

    REFLECT(OwnedObjectModel, a, b, c, d)
};
```

5.) If one or more of your types are incompatible and need special handling, consider specifying a map_from(source) method in your target class or a map_to(target) method in your source class. A user-defined assignment operator, user defined-conversion operator, or converting constructor is highly preferrable in most cases, only use these when you cannot use the former, or when the former is specified and you need unique behavior for object mappings.
```C++
struct UnownedEncapsulator
{
public:
    UnownedEncapsulator(int a) : a(a) {}
    int getA() const { return a; }
    void setA(int a) { this->a = a; }

private:
    int a;
};

struct OwnedObject1
{
    int a = 0;
    int c = 0;
    REFLECT(OwnedObject1, a)

    void map_to(UnownedEncapsulator & o) const { o.setA(this->a); }
    void map_from(const UnownedEncapsulator & o) { this->a = o.getA(); }
};
```
  
6.) As a last resort for objects (or when customizing mappings to/from standard types for more general purposes), specialize the two-argument ObjectMapper::map method (avoid specializing the one-arg method as that method simply calls the two-arg method, and the one-arg method will NOT be called when recursing down various parts of an object) e.g.

```C++
template <>
void ObjectMapper::map(SpecializationMapping & to, const OwnedObject1 & from)
{
    to.a = from.a;
}
```
