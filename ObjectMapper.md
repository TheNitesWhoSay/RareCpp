# Rare Object Mapper

A library for easily mapping between different types, taking advantage of reflection, standard language conversion mechanics, and object mapper-specific customizations.

Any two reflected objects containing fields of the same name and compatible types can be mapped to eachother with zero additional setup, e.g.

```C++
struct PersonDao
{
    int id;
    std::string firstName;
    std::string lastName;

    REFLECT(PersonDao, id, firstName, lastName)
};

struct PersonDto
{
    std::string firstName;
    std::string lastName;

    REFLECT(PersonDto, firstName, lastName)
};

int main()
{
    PersonDao dao{ 1337, "Leeroy", "Jenkins" };
    PersonDto dto{};
    ObjectMapper::map(dto, dao);
    std::cout << "dto: " << Json::pretty(dto) << std::endl;
}
```

```
dto: {
  "firstName": "Leeroy",
  "lastName": "Jenkins"
}
```

The above could also could have been compressed to one line with single-argument helper function:
```C++
  PersonDto dto = ObjectMapper::map<PersonDto>(dao);
```

## Automated Mapping Algorithm

When calling ObjectMapper::map, the order in which various mappings are attempted is as follows:
- Specializations of ObjectMapper::map<To, From>(To &, const From &)
- A matching map_from method in the destination/To class (may be generated by the MAP_FROM or MAP_WITH macro)
- A matching map_to method in the source/From class (may be generated by the MAP_TO or MAP_WITH macro)
- If the statement "to = from" is valid, then it is ran (user defined assignment or conversion operators, converting constructors)
- If the statement "to = static_cast<To>(from)" is valid, then it is ran (user defined explicit conversion operators)

Not finding any such (or if the above make explicit calls to ObjectMapper::map_default), the following is then considered in order:
- If To and From are compatible shared_ptrs, the source value is shared to target
- If To or From is a non-null pointer, it is dereferenced
- If To is a null unique or shared pointer, it is allocated then mapped to
- If to and from are both pairs or tuples, the individual values within are mapped to eachother
- If to and from are both STL containers or static arrays, the container "to" is cleared, then all the elements from "from" are constructed, recursively mapped, then added to it
- If to and from are both reflected, then a mapping is performed on all matching field names

If none of the above are satisfied, no mapping is performed; no exception is raised nor is any other indiciation given that there was no mapping found


## Defining Mappings / Best Practices

1.) If there are pre-existing user-defined assignment operators, user-defined conversion operators, or converting constructors appropriate for your mapping, do nothing! ObjectMapper will find them and use them automatically; consider adding assignment/conversion operators or constructors where they make sense in your codebase as these are more standard (albeit a little more work).

2.) When it is reasonable to do so, name source and target fields the same and add reflection to both objects; no additional code will be needed to perform mappings
  
3.) When one or both objects cannot be reflected within their own class, but the field names are the same and the fields are public or protected, consider adding a reflection proxy, e.g.
```C++
template <> struct Reflect::Proxy<PersonDao> : public PersonDao
{
    REFLECT(Reflect::Proxy<PersonDao>, id, firstName, lastName)
};
```

4.) When one or both objects cannot be reflected or the field names differ, but the types are compatible for mapping, consider the MAP_WITH macro (or MAP_FROM/MAP_TO for uni-directional mappings) wherein the left side is the fields from "this" and the right side the fields from the class you specify e.g. 
```C++
struct UnownedObjDao
{
    int a;
    int b;
    int c;
    std::map<int, int> d;
    std::vector<OwnedObject2> e;

    UnownedObjDao() : a(0), b(0), c(0), d({}), e({}) {}
};

struct OwnedObjectModel
{
    int a;
    int b;
    std::map<int, int> c;
    std::vector<OwnedObject1> d;

    MAP_WITH(UnownedObjDao,
        (a, a),
        (b, b),
        (c, d),
        (d, e)
    )

    REFLECT(OwnedObjectModel, a, b, c, d)
};
```

5.) If one or more of your types are incompatible and need special handling, consider specifying a map_from(source) method in your target class or a map_to(target) method in your source class. A user-defined assignment operator, user defined-conversion operator, or converting constructor is highly preferrable in most cases, only use these when you cannot use the former, or when the former is specified and you need unique behavior for object mappings. If you use ObjectMapper inside your map_to/map_from methods, be sure to use ObjectMapper::map_default rather than ObjectMapper::map to avoid infinite recursion.
```C++
struct UnownedEncapsulator
{
public:
    UnownedEncapsulator(int a) : a(a) {}
    int getA() const { return a; }
    void setA(int a) { this->a = a; }

private:
    int a;
};

struct OwnedObject1
{
    int a = 0;
    int c = 0;
    REFLECT(OwnedObject1, a)

    void map_to(UnownedEncapsulator & o) const { o.setA(this->a); }
    void map_from(const UnownedEncapsulator & o) { this->a = o.getA(); }
};
```
  
6.) As a last resort for objects (or when customizing mappings to/from standard types for more general purposes), specialize the two-argument ObjectMapper::map method (avoid specializing the one-arg method as that method simply calls the two-arg method, and the one-arg method will NOT be called when recursing down various parts of an object) e.g.

```C++
template <>
void ObjectMapper::map(SpecializationMapping & to, const OwnedObject1 & from)
{
    to.a = from.a;
}
```

## Constructors & Operator Overloads

You may define various constructors and operator overloads (such as copy constructors, converting constructors, assignment operators, and conversion operators) using ObjectMapper. If you choose to do so, be sure to use the ObjectMapper::map_default methods rather than the ObjectMapper::map methods to avoid infinite recursion.

```C++
struct Src
{
    int a = 0;
    int b = 0;

    REFLECT(Src, a, b)
};

struct Dest
{
    void operator=(const Src & src) { ObjectMapper::map_default(*this, src); }

    int a = 0;
    int b = 0;

    REFLECT(Dest, a, b)
};
```

## Annotations (Serializer Instructions)

ObjectMapper provides annotations that can instruct serializers to use another type to which your type has a mapping for I/O. This is perhaps most useful for objects coming from libraries included in your code which are not reflected or are otherwise not well-suited for serialization (e.g. DAOs that you need to convert to DTOs). Having a default mapping should tell a given serializer to behave akin to:

```C++
using D = ObjectMapper::GetDefaultMapping<T, typename Field::Annotations, OpAnnotations>;
D d = ObjectMapper::map<D>(value);
output << d;
```

Or deserializer to behave akin to:
```C++
using D = ObjectMapper::GetDefaultMapping<T, typename Field::Annotations, OpAnnotations>;
D d {};
input >> d;
return ObjectMapper::map<T>(d);
```


You can specify a default mapping (or op-level mapping) with...

1.) A class level annotation
```C++
NOTE(Dao, ObjectMapper::MappedBy<Dto>)
struct Dao {
    std::string a;
    REFLECT_NOTED(Dao, a)
};
```

2.) A field-level annotation
```C++
struct MyObj
{
    NOTE(Dao, ObjectMapper::MappedBy<Dto>)
    Dao dao;
}
```

3.) Using the macro
```C++
SET_DEFAULT_OBJECT_MAPPING(Dao, Dto)
```

4.) An op-level annotation (if supported by your extension) e.g.
```C++
Json::out<Json::Statics::Included, Json::OpNotes<ObjectMapper::UseMapping<Dao, Dto>>>(objectContainingDaos);
```

Two helpers are provided to assist in using defined mappings:
- bool HasDefaultMapping<T, FieldNotes = void, OpNotes = void>
- Type GetDefaultMapping<T, FieldNotes = void, OpNotes = void>

e.g.
```C++
if constexpr ( ObjectMapper::HasDefaultMapping<T> )
{
    using D = ObjectMapper::GetDefaultMapping<T>;
    ...
}
```
